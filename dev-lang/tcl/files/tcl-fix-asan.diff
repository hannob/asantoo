diff -Naur a/generic/tclIO.c b/generic/tclIO.c
--- a/generic/tclIO.c	2015-02-26 17:57:28.000000000 +0100
+++ b/generic/tclIO.c	2016-01-26 11:24:47.432663700 +0100
@@ -4323,7 +4323,18 @@
 		return -1;
 	    }
 	    flushed += statePtr->bufSize;
-	    if (saved == 0 || src[-1] != '\n') {
+
+	    /*
+ 	     * We just flushed.  So if we have needNlFlush set to record
+ 	     * that we need to flush because theres a (translated) newline
+ 	     * in the buffer, that's likely not true any more.  But there
+ 	     * is a tricky exception.  If we have saved bytes that did not
+ 	     * really get flushed and those bytes came from a translation
+ 	     * of a newline as the last thing taken from the src array,
+ 	     * then needNlFlush needs to remain set to flag that the
+ 	     * next buffer still needs a newline flush.
+ 	     */
+	    if (needNlFlush && (saved == 0 || src[-1] != '\n')) {
 		needNlFlush = 0;
 	    }
 	}
diff -Naur a/generic/tclVar.c b/generic/tclVar.c
--- a/generic/tclVar.c	2015-02-26 17:57:28.000000000 +0100
+++ b/generic/tclVar.c	2016-01-26 11:24:43.636663984 +0100
@@ -674,7 +674,7 @@
     }
     part1 = TclGetStringFromObj(part1Ptr, &len1);
 
-    if (!parsed && (*(part1 + len1 - 1) == ')')) {
+    if (!parsed && len1 && (*(part1 + len1 - 1) == ')')) {
 	/*
 	 * part1Ptr is possibly an unparsed array element.
 	 */
